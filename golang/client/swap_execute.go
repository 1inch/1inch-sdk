package client

import (
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"

	"github.com/1inch/1inch-sdk/golang/client/onchain"
	"github.com/1inch/1inch-sdk/golang/client/swap"
	"github.com/1inch/1inch-sdk/golang/helpers"
	"github.com/1inch/1inch-sdk/golang/helpers/consts/contracts"
	"github.com/1inch/1inch-sdk/golang/helpers/consts/tokens"
	"github.com/ethereum/go-ethereum/common"
)

// This file breaks convention. It sends transactions to the blockchain directly instead of using the 1inch API.

// ExecuteSwap executes a swap on the Ethereum blockchain using swap data generated by GetSwapData
func (s *SwapService) ExecuteSwap(config *swap.ExecuteSwapConfig) error {

	if s.client.WalletKey == "" {
		return fmt.Errorf("wallet key must be set in the client config")
	}

	if !config.SkipWarnings {
		ok, err := swap.ConfirmExecuteSwapWithUser(config, s.client.EthClient)
		if err != nil {
			return fmt.Errorf("failed to confirm swap: %v", err)
		}
		if !ok {
			return errors.New("user rejected trade")
		}
	}

	aggregationRouter, err := contracts.Get1inchRouterFromChainId(s.client.ChainId)
	if err != nil {
		return fmt.Errorf("failed to get 1inch router address: %v", err)
	}

	if !config.IsPermitSwap {
		err = s.executeSwapWithApproval(aggregationRouter, config.FromToken, config.Amount, config.TransactionData, config.SkipWarnings)
		if err != nil {
			return fmt.Errorf("failed to execute swap with approval: %v", err)
		}
	} else {
		err = s.executeSwapWithPermit(config.TransactionData)
		if err != nil {
			return fmt.Errorf("failed to execute swap with permit: %v", err)
		}
	}

	return nil
}

func (s *SwapService) executeSwapWithApproval(spenderAddress string, fromToken string, amount string, transactionData string, skipWarnings bool) error {

	var value *big.Int
	var err error
	if fromToken != tokens.NativeToken {
		// When swapping erc20 tokens, the value set on the transaction will be 0
		value = big.NewInt(0)

		allowance, err := onchain.ReadContractAllowance(s.client.EthClient, common.HexToAddress(fromToken), s.client.PublicAddress, common.HexToAddress(spenderAddress))
		if err != nil {
			return fmt.Errorf("failed to read allowance: %v", err)
		}

		amountBig, err := helpers.BigIntFromString(amount)
		if err != nil {
			return fmt.Errorf("failed to convert amount to big.Int: %v", err)
		}
		if allowance.Cmp(amountBig) <= 0 {
			if !skipWarnings {
				ok, err := swap.ConfirmApprovalWithUser(s.client.EthClient, s.client.PublicAddress.Hex(), fromToken)
				if err != nil {
					return fmt.Errorf("failed to confirm approval: %v", err)
				}
				if !ok {
					return errors.New("user rejected approval")
				}
			}

			erc20Config := onchain.Erc20ApprovalConfig{
				ChainId:        s.client.ChainId,
				Key:            s.client.WalletKey,
				Erc20Address:   common.HexToAddress(fromToken),
				PublicAddress:  s.client.PublicAddress,
				SpenderAddress: common.HexToAddress(spenderAddress),
			}
			err = onchain.ApproveTokenForRouter(s.client.EthClient, s.client.NonceCache, erc20Config)
			if err != nil {
				return fmt.Errorf("failed to approve token for router: %v", err)
			}
			helpers.Sleep()
		}
	} else {
		// When swapping from the native token, there is no need for an approval and the amount passed in must be explicitly set
		value, err = helpers.BigIntFromString(amount)
		if err != nil {
			return fmt.Errorf("failed to convert amount to big.Int: %v", err)
		}
	}

	hexData, err := hex.DecodeString(transactionData[2:])
	if err != nil {
		return fmt.Errorf("failed to decode swap data: %v", err)
	}

	aggregationRouter, err := contracts.Get1inchRouterFromChainId(s.client.ChainId)
	if err != nil {
		return fmt.Errorf("failed to get 1inch router address: %v", err)
	}

	txConfig := onchain.TxConfig{
		Description:   "Swap",
		PublicAddress: s.client.PublicAddress,
		PrivateKey:    s.client.WalletKey,
		ChainId:       big.NewInt(int64(s.client.ChainId)),
		Value:         value,
		To:            aggregationRouter,
		Data:          hexData,
	}
	err = onchain.ExecuteTransaction(txConfig, s.client.EthClient, s.client.NonceCache)
	if err != nil {
		return fmt.Errorf("failed to execute transaction: %v", err)
	}
	return nil
}

func (s *SwapService) executeSwapWithPermit(transactionData string) error {

	hexData, err := hex.DecodeString(transactionData[2:])
	if err != nil {
		return fmt.Errorf("failed to decode swap data: %v", err)
	}

	aggregationRouter, err := contracts.Get1inchRouterFromChainId(s.client.ChainId)
	if err != nil {
		return fmt.Errorf("failed to get 1inch router address: %v", err)
	}

	txConfig := onchain.TxConfig{
		Description:   "Swap",
		PublicAddress: s.client.PublicAddress,
		PrivateKey:    s.client.WalletKey,
		ChainId:       big.NewInt(int64(s.client.ChainId)),
		Value:         big.NewInt(0),
		To:            aggregationRouter,
		Data:          hexData,
	}
	err = onchain.ExecuteTransaction(txConfig, s.client.EthClient, s.client.NonceCache)
	if err != nil {
		return fmt.Errorf("failed to execute transaction: %v", err)
	}
	return nil
}

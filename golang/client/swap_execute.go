package client

import (
	"context"
	"crypto/ecdsa"
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/1inch/1inch-sdk/golang/client/onchain"
	"github.com/1inch/1inch-sdk/golang/client/swap"
	"github.com/1inch/1inch-sdk/golang/helpers"
	"github.com/1inch/1inch-sdk/golang/helpers/consts/amounts"
	"github.com/1inch/1inch-sdk/golang/helpers/consts/contracts"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
)

// This file breaks convention. It sends transactions to the blockchain directly instead of using the 1inch API.

// ExecuteSwap executes a swap on the Ethereum blockchain using swap data generated by GetSwapData
func (s *SwapService) ExecuteSwap(config *swap.ExecuteSwapConfig) error {

	if !config.SkipWarnings {
		ok, err := swap.ConfirmExecuteSwapWithUser(config, s.client.EthClient)
		if err != nil {
			return fmt.Errorf("failed to confirm swap: %v", err)
		}
		if !ok {
			return errors.New("user rejected trade")
		}
	}

	privateKey, err := crypto.HexToECDSA(s.client.WalletKey)
	if err != nil {
		return fmt.Errorf("failed to convert private key: %v", err)
	}

	chainID, err := s.client.EthClient.NetworkID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get network ID: %v", err)
	}

	// Assume spenderAddress is the address of the contract you are giving unlimited approval to spend your USDC
	spenderAddress := common.HexToAddress(contracts.AggregationRouterV5)

	if !config.IsPermitSwap {
		err = s.executeSwapWithPermit(spenderAddress.Hex(), chainID, config.FromToken, privateKey, config.TransactionData)
		if err != nil {
			return fmt.Errorf("failed to execute swap with permit: %v", err)
		}
	} else {
		err = s.executeSwapWithApproval(chainID, privateKey, config.TransactionData)
		if err != nil {
			return fmt.Errorf("failed to execute swap with approval: %v", err)
		}
	}

	return nil
}

func (s *SwapService) executeSwapWithPermit(spenderAddress string, chainID *big.Int, fromToken string, privateKey *ecdsa.PrivateKey, transactionData string) error {
	// Parse the USDC contract ABI to get the 'Approve' function signature
	parsedABI, err := abi.JSON(strings.NewReader(contracts.Erc20Abi))
	if err != nil {
		return fmt.Errorf("failed to parse USDC ABI: %v", err)
	}

	// TODO check if there is an appropriate approval balance instead of doing an unlimited approval

	// Pack the transaction data with the method signature and parameters
	data, err := parsedABI.Pack("approve", spenderAddress, amounts.BigMaxUint256)
	if err != nil {
		return fmt.Errorf("failed to pack data for approve: %v", err)
	}

	approvalTx := onchain.GetDynamicFeeTx(s.client.EthClient, chainID, s.client.PublicAddress, fromToken, data)

	// Sign the transaction
	approvalTxSigned, err := types.SignTx(approvalTx, types.LatestSignerForChainID(chainID), privateKey)
	if err != nil {
		return fmt.Errorf("failed to sign transaction: %v", err)
	}

	// Send the transaction
	err = s.client.EthClient.SendTransaction(context.Background(), approvalTxSigned)
	if err != nil {
		return fmt.Errorf("failed to send transaction: %v", err)
	}
	fmt.Printf("Approval transaction sent! Hash: %s\n", approvalTxSigned.Hash().Hex())

	_, err = onchain.WaitForTransaction(s.client.EthClient, approvalTxSigned.Hash())
	if err != nil {
		return fmt.Errorf("failed to get transaction receipt: %v", err)
	}

	// Sometimes the Ethereum client returns the old nonce. Adding a sleep here for now (still does not fix it 100%)
	helpers.Sleep()

	hexData, err := hex.DecodeString(transactionData[2:])
	if err != nil {
		return fmt.Errorf("failed to decode swap data: %v", err)
	}
	swapTx := onchain.GetDynamicFeeTx(s.client.EthClient, chainID, s.client.PublicAddress, contracts.AggregationRouterV5, hexData)

	// Sign the transaction
	swapTxSigned, err := types.SignTx(swapTx, types.LatestSignerForChainID(chainID), privateKey)
	if err != nil {
		return fmt.Errorf("failed to sign transaction: %v", err)
	}

	// Send the transaction
	err = s.client.EthClient.SendTransaction(context.Background(), swapTxSigned)
	if err != nil {
		return fmt.Errorf("failed to send transaction: %v", err)
	}

	fmt.Printf("Swap transaction sent! Hash: %s\n", swapTxSigned.Hash().Hex())

	_, err = onchain.WaitForTransaction(s.client.EthClient, swapTxSigned.Hash())
	if err != nil {
		return fmt.Errorf("failed to get transaction receipt: %v", err)
	}

	helpers.PrintBlockExplorerTxLink(s.client.ChainId, swapTxSigned.Hash().String())
	return nil
}

func (s *SwapService) executeSwapWithApproval(chainID *big.Int, privateKey *ecdsa.PrivateKey, transactionData string) error {

	hexData, err := hex.DecodeString(transactionData[2:])
	if err != nil {
		return fmt.Errorf("failed to decode swap data: %v", err)
	}
	permitSwapTx := onchain.GetDynamicFeeTx(s.client.EthClient, chainID, s.client.PublicAddress, contracts.AggregationRouterV5, hexData)

	// Sign the transaction
	permitSwapTxSigned, err := types.SignTx(permitSwapTx, types.LatestSignerForChainID(chainID), privateKey)
	if err != nil {
		return fmt.Errorf("failed to sign transaction: %v", err)
	}

	// Send the transaction
	err = s.client.EthClient.SendTransaction(context.Background(), permitSwapTxSigned)
	if err != nil {
		return fmt.Errorf("failed to send transaction: %v", err)
	}

	fmt.Println("Swap transaction sent!")
	helpers.PrintBlockExplorerTxLink(s.client.ChainId, permitSwapTxSigned.Hash().String())

	_, err = onchain.WaitForTransaction(s.client.EthClient, permitSwapTxSigned.Hash())
	if err != nil {
		return fmt.Errorf("failed to get transaction receipt: %v", err)
	}
	fmt.Printf("Transaction mined!")
	return nil
}

package client

import (
	"context"
	"encoding/hex"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"

	"1inch-sdk-golang/client/onchain"
	"1inch-sdk-golang/client/swap"
	"1inch-sdk-golang/helpers"
	"1inch-sdk-golang/helpers/consts/amounts"
	"1inch-sdk-golang/helpers/consts/contracts"
)

type SwapService service

type ExecuteSwapConfig struct {
	FromToken       string
	TransactionData string
	IsPermitSwap    bool
}

// ExecuteSwap executes a swap on the Ethereum blockchain using swap data generated by GetSwapData
func (s *SwapService) ExecuteSwap(config *ExecuteSwapConfig) error {

	privateKey, err := crypto.HexToECDSA(s.client.WalletKey)
	if err != nil {
		return fmt.Errorf("failed to convert private key: %v", err)
	}

	chainID, err := s.client.EthClient.NetworkID(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get network ID: %v", err)
	}

	// Assume spenderAddress is the address of the contract you are giving unlimited approval to spend your USDC
	spenderAddress := common.HexToAddress(contracts.AggregationRouterV5)

	_, err = swap.GetTypeHash(s.client.EthClient, config.FromToken)
	if err != nil {

		fmt.Println("Permit may not available on this token. Proceeding with swap without Permit")

		// Parse the USDC contract ABI to get the 'Approve' function signature
		parsedABI, err := abi.JSON(strings.NewReader(contracts.Erc20Abi))
		if err != nil {
			return fmt.Errorf("failed to parse USDC ABI: %v", err)
		}

		// Pack the transaction data with the method signature and parameters
		data, err := parsedABI.Pack("approve", spenderAddress, amounts.BigMaxUint256)
		if err != nil {
			return fmt.Errorf("failed to pack data for approve: %v", err)
		}

		tx := onchain.GetDynamicFeeTx(s.client.EthClient, chainID, s.client.PublicAddress, config.FromToken, data)

		// Sign the transaction
		signedTx, err := types.SignTx(tx, types.LatestSignerForChainID(chainID), privateKey)
		if err != nil {
			return fmt.Errorf("failed to sign transaction: %v", err)
		}

		// Send the transaction
		err = s.client.EthClient.SendTransaction(context.Background(), signedTx)
		if err != nil {
			return fmt.Errorf("failed to send transaction: %v", err)
		}
		log.Printf("Approval transaction sent! Hash: %s\n", signedTx.Hash().Hex()) // TODO setup proper logger

		_, err = onchain.WaitForTransaction(s.client.EthClient, signedTx.Hash())
		if err != nil {
			return fmt.Errorf("failed to get transaction receipt: %v", err)
		}

		// Sometimes the Ethereum client returns the old nonce. Adding a sleep here for now (still does not fix it 100%)
		helpers.Sleep()

		hexData, err := hex.DecodeString(config.TransactionData[2:])
		if err != nil {
			return fmt.Errorf("failed to decode swap data: %v", err)
		}
		tx2 := onchain.GetDynamicFeeTx(s.client.EthClient, chainID, s.client.PublicAddress, contracts.AggregationRouterV5, hexData)

		// Sign the transaction
		signedTx2, err := types.SignTx(tx2, types.LatestSignerForChainID(chainID), privateKey)
		if err != nil {
			return fmt.Errorf("failed to sign transaction: %v", err)
		}

		// Send the transaction
		err = s.client.EthClient.SendTransaction(context.Background(), signedTx2)
		if err != nil {
			return fmt.Errorf("failed to send transaction: %v", err)
		}

		log.Printf("Swap transaction sent! Hash: %s\n", signedTx2.Hash().Hex())

		receipt2, err := onchain.WaitForTransaction(s.client.EthClient, signedTx2.Hash())
		if err != nil {
			return fmt.Errorf("failed to get transaction receipt: %v", err)
		}
		fmt.Printf("Transaction mined! Block hash: %v\n", receipt2.BlockHash)
	} else {
		fmt.Println("Permit found on this token. Proceeding with swap using Permit")

		permitSignatureConfig := &swap.PermitSignatureConfig{
			FromToken:     config.FromToken,
			Name:          "Frax", // TODO get this from the contract directly
			PublicAddress: s.client.PublicAddress.Hex(),
			ChainId:       s.client.ChainId,
			Key:           s.client.WalletKey,
			Nonce:         1,
			Deadline:      1704250835, // TODO use time.Now().Add(time.Minute).Unix()
		}

		sig, err := swap.CreatePermitSignature(permitSignatureConfig)
		if err != nil {
			return fmt.Errorf("failed to create permit signature: %v", err)
		}
		fmt.Printf("Signature: %v\n", sig)

		hexData, err := hex.DecodeString(config.TransactionData[2:])
		if err != nil {
			return fmt.Errorf("failed to decode swap data: %v", err)
		}
		tx2 := onchain.GetDynamicFeeTx(s.client.EthClient, chainID, s.client.PublicAddress, contracts.AggregationRouterV5, hexData)

		// Sign the transaction
		signedTx2, err := types.SignTx(tx2, types.LatestSignerForChainID(chainID), privateKey)
		if err != nil {
			return fmt.Errorf("failed to sign transaction: %v", err)
		}

		// Send the transaction
		err = s.client.EthClient.SendTransaction(context.Background(), signedTx2)
		if err != nil {
			return fmt.Errorf("failed to send transaction: %v", err)
		}

		log.Printf("Swap transaction sent! Hash: %s\n", signedTx2.Hash().Hex())

		receipt2, err := onchain.WaitForTransaction(s.client.EthClient, signedTx2.Hash())
		if err != nil {
			return fmt.Errorf("failed to get transaction receipt: %v", err)
		}
		fmt.Printf("Transaction mined! Block hash: %v\n", receipt2.BlockHash)
	}

	return nil
}

func (s *SwapService) ApproveAllowance(ctx context.Context, params swap.ApproveControllerGetAllowanceParams) (*swap.AllowanceResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/approve/allowance", s.client.ChainId)

	err := params.Validate()
	if err != nil {
		return nil, nil, err
	}

	u, err = addQueryParameters(u, params)
	if err != nil {
		return nil, nil, err
	}

	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var allowanceResponse swap.AllowanceResponse
	res, err := s.client.Do(ctx, req, &allowanceResponse)
	if err != nil {
		return nil, nil, err
	}

	return &allowanceResponse, res, nil
}

func (s *SwapService) ApproveSpender(ctx context.Context) (*swap.SpenderResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/approve/spender", s.client.ChainId)

	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var spender swap.SpenderResponse
	res, err := s.client.Do(ctx, req, &spender)
	if err != nil {
		return nil, nil, err
	}

	return &spender, res, nil
}

func (s *SwapService) ApproveTransaction(ctx context.Context, params swap.ApproveControllerGetCallDataParams) (*swap.ApproveCallDataResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/approve/transaction", s.client.ChainId)

	err := params.Validate()
	if err != nil {
		return nil, nil, err
	}

	u, err = addQueryParameters(u, params)
	if err != nil {
		return nil, nil, err
	}

	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var approveCallData swap.ApproveCallDataResponse
	res, err := s.client.Do(ctx, req, &approveCallData)
	if err != nil {
		return nil, nil, err
	}

	return &approveCallData, res, nil
}

func (s *SwapService) GetLiquiditySources(ctx context.Context) (*swap.ProtocolsResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/liquidity-sources", s.client.ChainId)

	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var liquiditySources swap.ProtocolsResponse
	res, err := s.client.Do(ctx, req, &liquiditySources)
	if err != nil {
		return nil, nil, err
	}

	return &liquiditySources, res, nil
}

func (s *SwapService) GetQuote(ctx context.Context, params swap.AggregationControllerGetQuoteParams) (*swap.QuoteResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/quote", s.client.ChainId)

	err := params.Validate()
	if err != nil {
		return nil, nil, err
	}

	u, err = addQueryParameters(u, params)
	if err != nil {
		return nil, nil, err
	}

	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var quote swap.QuoteResponse
	res, err := s.client.Do(ctx, req, &quote)
	if err != nil {
		return nil, nil, err
	}

	return &quote, res, nil
}

func (s *SwapService) GetSwapData(ctx context.Context, params swap.AggregationControllerGetSwapParams) (*swap.SwapResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/swap", s.client.ChainId)

	err := params.Validate()
	if err != nil {
		return nil, nil, err
	}

	u, err = addQueryParameters(u, params)
	if err != nil {
		return nil, nil, err
	}
	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var swapResponse swap.SwapResponse // TODO the struct does not match the response well
	res, err := s.client.Do(ctx, req, &swapResponse)
	if err != nil {
		return nil, nil, err
	}

	swapResponse.FromToken = &swap.TokenInfo{
		Address: params.Src,
	}

	return &swapResponse, res, nil
}

func (s *SwapService) GetTokens(ctx context.Context) (*swap.TokensResponse, *http.Response, error) {
	u := fmt.Sprintf("/swap/v5.2/%d/tokens", s.client.ChainId)

	req, err := s.client.NewRequest("GET", u, nil)
	if err != nil {
		return nil, nil, err
	}

	var tokens swap.TokensResponse
	res, err := s.client.Do(ctx, req, &tokens)
	if err != nil {
		return nil, nil, err
	}

	return &tokens, res, nil
}
